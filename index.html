<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Midnight Blockchain: Hashes</title>
		<style>
			:root {
				color-scheme: dark;
				--bg: #0b0f17;
				--panel: #121a2a;
				--text: #e7eefc;
				--muted: #b7c2d9;
				--border: #23304a;
				--accent: #7aa2ff;
			}

			body {
				margin: 0;
				background: var(--bg);
				color: var(--text);
				font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
			}

			.wrap {
				max-width: 900px;
				margin: 48px auto;
				padding: 0 16px;
			}

			h1 {
				margin: 0 0 8px;
				font-size: 22px;
			}

			p {
				margin: 0 0 16px;
				color: var(--muted);
			}

			.card {
				background: var(--panel);
				border: 1px solid var(--border);
				border-radius: 12px;
				padding: 16px;
			}

			label {
				display: block;
				margin-bottom: 8px;
				color: var(--muted);
			}

			textarea {
				width: 100%;
				min-height: 110px;
				resize: vertical;
				border-radius: 10px;
				border: 1px solid var(--border);
				background: #0d1424;
				color: var(--text);
				padding: 10px;
				font: 13px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
				outline: none;

			input[type='checkbox'] {
				width: 14px;
				height: 14px;
				accent-color: var(--accent);
			}
			}

			.row {
				margin-top: 12px;
				display: grid;
				grid-template-columns: 1fr;
				gap: 10px;
			}

			.out {
				border-radius: 10px;
				border: 1px solid var(--border);
				background: #0d1424;
				padding: 10px;
				font: 13px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
				overflow: auto;
			}

			input[type='number'] {
				width: 140px;
				border-radius: 10px;
				border: 1px solid var(--border);
				background: #0d1424;
				color: var(--text);
				padding: 8px 10px;
				outline: none;
				font: 13px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
			}

			.hint {
				margin-top: 10px;
				font-size: 12px;
				color: var(--muted);
			}

			.hint b {
				color: var(--accent);
				font-weight: 600;
			}

			button {
				appearance: none;
				border: 1px solid var(--border);
				background: #0d1424;
				color: var(--text);
				padding: 8px 10px;
				border-radius: 10px;
				cursor: pointer;
				font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
			}

			button:hover {
				border-color: #2f426a;
			}

			.pill {
				display: inline-block;
				padding: 2px 8px;
				border-radius: 999px;
				border: 1px solid var(--border);
				background: #0d1424;
				font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
			}

			.ok {
				color: #7dffb2;
			}

			.bad {
				color: #ff8a8a;
			}
		</style>
	</head>
	<body>
		<div class="wrap">
			<h1>Midnight Blockchain — Step 1: Hashes</h1>
			<p>
				A blockchain is built from one simple tool: a <b>hash</b> (a one-way fingerprint of data).
				Change the input even a little — the fingerprint changes a lot.
			</p>

			<div class="card">
				<label for="msg">Message (data we want to fingerprint)</label>
				<textarea id="msg">Hello, midnight pair-programming.</textarea>

				<div class="row">
					<div>
						<label>SHA-256 hash (fingerprint)</label>
						<div id="hash" class="out" aria-live="polite"></div>
					</div>
				</div>

				<div class="hint">
					If the hash doesn’t update, you may be opening this file without a local server.
					Try a simple server (e.g. <b>python -m http.server</b>) and open <b>http://localhost:8000</b>.
				</div>
			</div>

			<div style="height: 16px"></div>

			<div class="card">
				<h2 style="margin: 0 0 8px; font-size: 16px">Step 2: A Block (data + prevHash)</h2>
				<p style="margin: 0 0 14px; color: var(--muted)">
					A block’s hash is a fingerprint of <b>its data</b> and the <b>previous block’s hash</b>.
					That “prevHash” link is what makes a chain.
				</p>

				<label for="blockData">Block data</label>
				<textarea id="blockData">Send 10 tokens to Ada.</textarea>

				<div style="height: 10px"></div>

				<label for="prevHash">Previous hash (what we chain to)</label>
				<textarea id="prevHash" spellcheck="false">0000000000000000000000000000000000000000000000000000000000000000</textarea>

				<div style="height: 10px"></div>

				<div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap">
					<span class="pill">Timestamp: <span id="timestamp">(loading)</span></span>
					<button id="newTimestampBtn" type="button">New timestamp</button>
				</div>

				<div style="height: 10px"></div>

				<div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap">
					<label style="margin: 0">
						Nonce
						<input id="nonce" type="number" min="0" step="1" value="0" />
					</label>
					<label style="margin: 0">
						Difficulty (leading zeros)
						<input id="difficulty" type="number" min="0" max="8" step="1" value="3" />
					</label>
					<button id="mineBtn" type="button">Mine</button>
					<button id="stopMineBtn" type="button" disabled>Stop</button>
					<span class="pill">Attempts: <span id="attempts">0</span></span>
				</div>

				<div class="row">
					<div>
						<label>Block JSON (what we hash)</label>
						<div id="blockJson" class="out"></div>
					</div>
					<div>
						<label>Block hash</label>
						<div id="blockHash" class="out" aria-live="polite"></div>
					</div>
				</div>

				<div style="height: 10px"></div>

				<div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap">
					<button id="storeHashBtn" type="button">Store this hash</button>
					<span class="pill">Stored hash: <span id="storedHash">(none)</span></span>
					<span class="pill">Check: <span id="validity">(no stored hash)</span></span>
				</div>

				<div class="hint" style="margin-top: 10px">
					Click <b>Store this hash</b>, then edit the block data. If the stored hash no longer matches the recomputed hash,
					the block has been tampered with.
				</div>
			</div>

			<div style="height: 16px"></div>

			<div class="card">
				<h2 style="margin: 0 0 8px; font-size: 16px">Step 3: Two Blocks = A Chain</h2>
				<p style="margin: 0 0 14px; color: var(--muted)">
					Block 2’s <b>prevHash</b> is Block 1’s hash. Change Block 1, and Block 2 instantly changes too.
				</p>

				<label for="block2Data">Block 2 data</label>
				<textarea id="block2Data">Send 3 tokens to Grace.</textarea>

				<div style="height: 10px"></div>

				<div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap">
					<span class="pill">Block 2 prevHash (auto): <span id="block2PrevHash">(loading)</span></span>
					<span class="pill">Link: <span id="chainLink">(loading)</span></span>
				</div>

				<div style="height: 10px"></div>

				<div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap">
					<span class="pill">Block 2 timestamp: <span id="block2Timestamp">(loading)</span></span>
					<button id="newBlock2TimestampBtn" type="button">New timestamp</button>
					<label style="margin: 0">
						Block 2 nonce
						<input id="block2Nonce" type="number" min="0" step="1" value="0" />
					</label>
					<button id="mine2Btn" type="button">Mine Block 2</button>
					<button id="stopMine2Btn" type="button" disabled>Stop</button>
					<span class="pill">Attempts: <span id="attempts2">0</span></span>
					<span class="pill">PoW: <span id="pow2">(loading)</span></span>
				</div>

				<div class="row" style="margin-top: 12px">
					<div>
						<label>Block 2 JSON (what we hash)</label>
						<div id="block2Json" class="out"></div>
					</div>
					<div>
						<label>Block 2 hash</label>
						<div id="block2Hash" class="out" aria-live="polite"></div>
					</div>
				</div>
			</div>

			<div style="height: 16px"></div>

			<div class="card">
				<h2 style="margin: 0 0 8px; font-size: 16px">Step 4: Ledger View</h2>
				<p style="margin: 0 0 14px; color: var(--muted)">
					A blockchain is basically a ledger: a list of blocks plus rules for what “valid” means.
				</p>

				<div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap">
					<span class="pill">Chain status: <span id="chainStatus">(loading)</span></span>
					<span class="pill">
						<label style="margin: 0; display: inline-flex; gap: 8px; align-items: center">
							<input id="ruleLink" type="checkbox" checked />
							require link
						</label>
					</span>
					<span class="pill">
						<label style="margin: 0; display: inline-flex; gap: 8px; align-items: center">
							<input id="rulePow" type="checkbox" checked />
							require PoW
						</label>
					</span>
				</div>

				<div style="height: 12px"></div>

				<div class="row">
					<div>
						<label>Block 1 (hash)</label>
						<div id="ledgerB1" class="out"></div>
					</div>
					<div>
						<label>Block 2 (hash)</label>
						<div id="ledgerB2" class="out"></div>
					</div>
				</div>
			</div>

			<div style="height: 16px"></div>

			<div class="card">
				<h2 style="margin: 0 0 8px; font-size: 16px">Step 5: Consensus (Fork Demo)</h2>
				<p style="margin: 0 0 14px; color: var(--muted)">
					Real blockchains can have competing chains (forks). The "longest chain" or "most work" rule decides which one is canonical.
				</p>

				<div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap">
					<button id="forkBtn" type="button">Create Fork (Block 2')</button>
					<span class="pill">Fork status: <span id="forkStatus">no fork</span></span>
				</div>

				<div style="height: 12px"></div>

				<div id="forkContainer" style="display: none">
					<label for="block2AltData">Block 2' (alternate) data</label>
					<textarea id="block2AltData">Send 5 tokens to Bob.</textarea>

					<div style="height: 10px"></div>

					<div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap">
						<span class="pill">Block 2' timestamp: <span id="block2AltTimestamp">(loading)</span></span>
						<button id="newBlock2AltTimestampBtn" type="button">New timestamp</button>
						<label style="margin: 0">
							Block 2' nonce
							<input id="block2AltNonce" type="number" min="0" step="1" value="0" />
						</label>
						<button id="mine2AltBtn" type="button">Mine Block 2'</button>
						<button id="stopMine2AltBtn" type="button" disabled>Stop</button>
						<span class="pill">Attempts: <span id="attempts2Alt">0</span></span>
						<span class="pill">PoW: <span id="pow2Alt">(loading)</span></span>
					</div>

					<div class="row" style="margin-top: 12px">
						<div>
							<label>Block 2' JSON</label>
							<div id="block2AltJson" class="out"></div>
						</div>
						<div>
							<label>Block 2' hash</label>
							<div id="block2AltHash" class="out" aria-live="polite"></div>
						</div>
					</div>

					<div style="height: 12px"></div>

					<div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap">
						<span class="pill">Main chain (Block 1 → 2): work=<span id="mainChainLen">0</span></span>
						<span class="pill">Fork chain (Block 1 → 2'): work=<span id="forkChainLen">0</span></span>
						<span class="pill">Winner: <span id="winner">(loading)</span></span>
					</div>

					<div class="hint" style="margin-top: 10px">
						Both chains share Block 1. If both sides do the same total work, we have a tie.
						In a real network, the next block (3 or 3') usually breaks the tie.
					</div>

					<div style="height: 14px"></div>

					<h3 style="margin: 0 0 8px; font-size: 14px; color: var(--muted)">Tie-breaker: next block (3 vs 3')</h3>
					<p style="margin: 0 0 12px; color: var(--muted)">
						Mine Block 3 on one chain to make it longer.
					</p>

					<div class="row">
						<div>
							<label for="block3Data">Main chain: Block 3 data</label>
							<textarea id="block3Data">Main chain block 3.</textarea>

							<div style="height: 10px"></div>
							<div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap">
								<span class="pill">Block 3 timestamp: <span id="block3Timestamp">(loading)</span></span>
								<button id="newBlock3TimestampBtn" type="button">New timestamp</button>
								<label style="margin: 0">
									Block 3 nonce
									<input id="block3Nonce" type="number" min="0" step="1" value="0" />
								</label>
								<button id="mine3Btn" type="button">Mine Block 3</button>
								<button id="stopMine3Btn" type="button" disabled>Stop</button>
								<span class="pill">Attempts: <span id="attempts3">0</span></span>
								<span class="pill">PoW: <span id="pow3">(loading)</span></span>
							</div>

							<div class="row" style="margin-top: 12px">
								<div>
									<label>Block 3 JSON</label>
									<div id="block3Json" class="out"></div>
								</div>
								<div>
									<label>Block 3 hash</label>
									<div id="block3Hash" class="out" aria-live="polite"></div>
								</div>
							</div>
						</div>

						<div>
							<label for="block3AltData">Fork chain: Block 3' data</label>
							<textarea id="block3AltData">Fork chain block 3'.</textarea>

							<div style="height: 10px"></div>
							<div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap">
								<span class="pill">Block 3' timestamp: <span id="block3AltTimestamp">(loading)</span></span>
								<button id="newBlock3AltTimestampBtn" type="button">New timestamp</button>
								<label style="margin: 0">
									Block 3' nonce
									<input id="block3AltNonce" type="number" min="0" step="1" value="0" />
								</label>
								<button id="mine3AltBtn" type="button">Mine Block 3'</button>
								<button id="stopMine3AltBtn" type="button" disabled>Stop</button>
								<span class="pill">Attempts: <span id="attempts3Alt">0</span></span>
								<span class="pill">PoW: <span id="pow3Alt">(loading)</span></span>
							</div>

							<div class="row" style="margin-top: 12px">
								<div>
									<label>Block 3' JSON</label>
									<div id="block3AltJson" class="out"></div>
								</div>
								<div>
									<label>Block 3' hash</label>
									<div id="block3AltHash" class="out" aria-live="polite"></div>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>

		<script>
			const msgEl = document.getElementById('msg');
			const hashEl = document.getElementById('hash');
			const blockDataEl = document.getElementById('blockData');
			const prevHashEl = document.getElementById('prevHash');
			const blockJsonEl = document.getElementById('blockJson');
			const blockHashEl = document.getElementById('blockHash');
			const storeHashBtn = document.getElementById('storeHashBtn');
			const storedHashEl = document.getElementById('storedHash');
			const validityEl = document.getElementById('validity');
			const timestampEl = document.getElementById('timestamp');
			const newTimestampBtn = document.getElementById('newTimestampBtn');
			const nonceEl = document.getElementById('nonce');
			const difficultyEl = document.getElementById('difficulty');
			const mineBtn = document.getElementById('mineBtn');
			const stopMineBtn = document.getElementById('stopMineBtn');
			const attemptsEl = document.getElementById('attempts');
			const block2DataEl = document.getElementById('block2Data');
			const block2PrevHashEl = document.getElementById('block2PrevHash');
			const chainLinkEl = document.getElementById('chainLink');
			const block2TimestampEl = document.getElementById('block2Timestamp');
			const newBlock2TimestampBtn = document.getElementById('newBlock2TimestampBtn');
			const block2NonceEl = document.getElementById('block2Nonce');
			const block2JsonEl = document.getElementById('block2Json');
			const block2HashEl = document.getElementById('block2Hash');
			const mine2Btn = document.getElementById('mine2Btn');
			const stopMine2Btn = document.getElementById('stopMine2Btn');
			const attempts2El = document.getElementById('attempts2');
			const pow2El = document.getElementById('pow2');
			const chainStatusEl = document.getElementById('chainStatus');
			const ledgerB1El = document.getElementById('ledgerB1');
			const ledgerB2El = document.getElementById('ledgerB2');
			const ruleLinkEl = document.getElementById('ruleLink');
			const rulePowEl = document.getElementById('rulePow');
			const forkBtn = document.getElementById('forkBtn');
			const forkStatusEl = document.getElementById('forkStatus');
			const forkContainer = document.getElementById('forkContainer');
			const block2AltDataEl = document.getElementById('block2AltData');
			const block2AltTimestampEl = document.getElementById('block2AltTimestamp');
			const newBlock2AltTimestampBtn = document.getElementById('newBlock2AltTimestampBtn');
			const block2AltNonceEl = document.getElementById('block2AltNonce');
			const block2AltJsonEl = document.getElementById('block2AltJson');
			const block2AltHashEl = document.getElementById('block2AltHash');
			const mine2AltBtn = document.getElementById('mine2AltBtn');
			const stopMine2AltBtn = document.getElementById('stopMine2AltBtn');
			const attempts2AltEl = document.getElementById('attempts2Alt');
			const pow2AltEl = document.getElementById('pow2Alt');
			const mainChainLenEl = document.getElementById('mainChainLen');
			const forkChainLenEl = document.getElementById('forkChainLen');
			const winnerEl = document.getElementById('winner');
			const block3DataEl = document.getElementById('block3Data');
			const block3TimestampEl = document.getElementById('block3Timestamp');
			const newBlock3TimestampBtn = document.getElementById('newBlock3TimestampBtn');
			const block3NonceEl = document.getElementById('block3Nonce');
			const mine3Btn = document.getElementById('mine3Btn');
			const stopMine3Btn = document.getElementById('stopMine3Btn');
			const attempts3El = document.getElementById('attempts3');
			const pow3El = document.getElementById('pow3');
			const block3JsonEl = document.getElementById('block3Json');
			const block3HashEl = document.getElementById('block3Hash');
			const block3AltDataEl = document.getElementById('block3AltData');
			const block3AltTimestampEl = document.getElementById('block3AltTimestamp');
			const newBlock3AltTimestampBtn = document.getElementById('newBlock3AltTimestampBtn');
			const block3AltNonceEl = document.getElementById('block3AltNonce');
			const mine3AltBtn = document.getElementById('mine3AltBtn');
			const stopMine3AltBtn = document.getElementById('stopMine3AltBtn');
			const attempts3AltEl = document.getElementById('attempts3Alt');
			const pow3AltEl = document.getElementById('pow3Alt');
			const block3AltJsonEl = document.getElementById('block3AltJson');
			const block3AltHashEl = document.getElementById('block3AltHash');

			let storedBlockHash = '';
			let blockTimestamp = new Date().toISOString();
			let block2Timestamp = new Date().toISOString();
			let block2AltTimestamp = new Date().toISOString();
			let block3Timestamp = new Date().toISOString();
			let block3AltTimestamp = new Date().toISOString();
			let mining = false;
			let mining2 = false;
			let mining2Alt = false;
			let mining3 = false;
			let mining3Alt = false;
			let attempts = 0;
			let attempts2 = 0;
			let attempts2Alt = 0;
			let attempts3 = 0;
			let attempts3Alt = 0;
			let lastBlock1Hash = '';
			let lastBlock2Hash = '';
			let lastBlock2AltHash = '';
			let forkActive = false;

			function bytesToHex(buffer) {
				const bytes = new Uint8Array(buffer);
				let hex = '';
				for (const b of bytes) hex += b.toString(16).padStart(2, '0');
				return hex;
			}

			async function sha256(text) {
				const data = new TextEncoder().encode(text);
				const digest = await crypto.subtle.digest('SHA-256', data);
				return bytesToHex(digest);
			}

			function stableStringify(value) {
				if (value === null || typeof value !== 'object') return JSON.stringify(value);
				if (Array.isArray(value)) return '[' + value.map(stableStringify).join(',') + ']';
				const keys = Object.keys(value).sort();
				const props = keys.map((k) => JSON.stringify(k) + ':' + stableStringify(value[k]));
				return '{' + props.join(',') + '}';
			}

			function leadingZeroWork(hexHash) {
				// Simple “work” proxy: count of leading '0' hex chars.
				// More zeros => rarer => more work.
				let count = 0;
				for (const ch of hexHash) {
					if (ch !== '0') break;
					count += 1;
				}
				return count;
			}

			async function refresh() {
				try {
					const text = msgEl.value;
					const h = await sha256(text);
					hashEl.textContent = h;

					const nonce = Number(nonceEl.value) || 0;

					const block = {
						index: 1,
						timestamp: blockTimestamp,
						data: blockDataEl.value,
						prevHash: prevHashEl.value.trim(),
						nonce,
					};

					const blockJson = stableStringify(block);
					blockJsonEl.textContent = blockJson;
					const currentBlockHash = await sha256(blockJson);
					blockHashEl.textContent = currentBlockHash;
					lastBlock1Hash = currentBlockHash;

					timestampEl.textContent = blockTimestamp;
					attemptsEl.textContent = String(attempts);
					attempts2El.textContent = String(attempts2);
					attempts3El.textContent = String(attempts3);
					attempts3AltEl.textContent = String(attempts3Alt);

					storedHashEl.textContent = storedBlockHash ? storedBlockHash : '(none)';
					if (!storedBlockHash) {
						validityEl.textContent = '(no stored hash)';
						validityEl.className = '';
					} else if (storedBlockHash === currentBlockHash) {
						validityEl.textContent = 'valid';
						validityEl.className = 'ok';
					} else {
						validityEl.textContent = 'INVALID (tampered)';
						validityEl.className = 'bad';
					}

					const block2PrevHash = lastBlock1Hash;
					block2PrevHashEl.textContent = block2PrevHash || '(unknown)';

					const block2 = {
						index: 2,
						timestamp: block2Timestamp,
						data: block2DataEl.value,
						prevHash: block2PrevHash,
						nonce: Number(block2NonceEl.value) || 0,
					};

					block2TimestampEl.textContent = block2Timestamp;
					const block2Json = stableStringify(block2);
					block2JsonEl.textContent = block2Json;
					const block2Hash = await sha256(block2Json);
					block2HashEl.textContent = block2Hash;
					lastBlock2Hash = block2Hash;

					const difficulty = Math.max(0, Math.min(8, Number(difficultyEl.value) || 0));
					const prefix = '0'.repeat(difficulty);
					const pow1Ok = currentBlockHash.startsWith(prefix);
					const pow2Ok = block2Hash.startsWith(prefix);
					// Block 3 (main chain)
					const block3 = {
						index: 3,
						timestamp: block3Timestamp,
						data: block3DataEl.value,
						prevHash: block2Hash,
						nonce: Number(block3NonceEl.value) || 0,
					};
					block3TimestampEl.textContent = block3Timestamp;
					const block3Json = stableStringify(block3);
					block3JsonEl.textContent = block3Json;
					const block3Hash = await sha256(block3Json);
					block3HashEl.textContent = block3Hash;
					const pow3Ok = block3Hash.startsWith(prefix);
					if (pow3Ok) {
						pow3El.textContent = 'ok';
						pow3El.className = 'ok';
					} else {
						pow3El.textContent = `need prefix ${prefix || '(none)'}`;
						pow3El.className = 'bad';
					}
					if (block2Hash.startsWith(prefix)) {
						pow2El.textContent = 'ok';
						pow2El.className = 'ok';
					} else {
						pow2El.textContent = `need prefix ${prefix || '(none)'}`;
						pow2El.className = 'bad';
					}

					if (block2.prevHash === lastBlock1Hash) {
						chainLinkEl.textContent = 'linked';
						chainLinkEl.className = 'ok';
					} else {
						chainLinkEl.textContent = 'BROKEN';
						chainLinkEl.className = 'bad';
					}

					// Ledger summary
					const linkedOk = block2.prevHash === currentBlockHash;
					const requireLink = Boolean(ruleLinkEl.checked);
					const requirePow = Boolean(rulePowEl.checked);

					const b1PowText = pow1Ok ? 'ok' : `need prefix ${prefix || '(none)'}`;
					const b2PowText = pow2Ok ? 'ok' : `need prefix ${prefix || '(none)'}`;
					ledgerB1El.textContent = `${currentBlockHash}\nPoW: ${b1PowText}`;
					ledgerB2El.textContent = `${block2Hash}\nprevHash: ${block2.prevHash}\nPoW: ${b2PowText}`;

					const linkPass = !requireLink || linkedOk;
					const powPass = !requirePow || (pow1Ok && pow2Ok);
					if (linkPass && powPass) {
						chainStatusEl.textContent = 'VALID';
						chainStatusEl.className = 'ok';
					} else {
						const reasons = [
							requireLink && !linkedOk ? 'broken link' : null,
							requirePow && !pow1Ok ? 'block 1 not mined' : null,
							requirePow && !pow2Ok ? 'block 2 not mined' : null,
						].filter(Boolean);
						chainStatusEl.textContent = `INVALID (${reasons.join(', ')})`;
						chainStatusEl.className = 'bad';
					}

					// Fork logic
					if (forkActive) {
						forkStatusEl.textContent = 'active';
						forkStatusEl.className = 'ok';
						attempts2AltEl.textContent = String(attempts2Alt);

						const block2Alt = {
							index: 2,
							timestamp: block2AltTimestamp,
							data: block2AltDataEl.value,
							prevHash: lastBlock1Hash,
							nonce: Number(block2AltNonceEl.value) || 0,
						};

						block2AltTimestampEl.textContent = block2AltTimestamp;
						const block2AltJson = stableStringify(block2Alt);
						block2AltJsonEl.textContent = block2AltJson;
						const block2AltHash = await sha256(block2AltJson);
						block2AltHashEl.textContent = block2AltHash;
						lastBlock2AltHash = block2AltHash;

						const pow2AltOk = block2AltHash.startsWith(prefix);
						if (pow2AltOk) {
							pow2AltEl.textContent = 'ok';
							pow2AltEl.className = 'ok';
						} else {
							pow2AltEl.textContent = `need prefix ${prefix || '(none)'}`;
							pow2AltEl.className = 'bad';
						}

						// Block 3' (fork chain)
						const block3Alt = {
							index: 3,
							timestamp: block3AltTimestamp,
							data: block3AltDataEl.value,
							prevHash: block2AltHash,
							nonce: Number(block3AltNonceEl.value) || 0,
						};
						block3AltTimestampEl.textContent = block3AltTimestamp;
						const block3AltJson = stableStringify(block3Alt);
						block3AltJsonEl.textContent = block3AltJson;
						const block3AltHash = await sha256(block3AltJson);
						block3AltHashEl.textContent = block3AltHash;
						const pow3AltOk = block3AltHash.startsWith(prefix);
						if (pow3AltOk) {
							pow3AltEl.textContent = 'ok';
							pow3AltEl.className = 'ok';
						} else {
							pow3AltEl.textContent = `need prefix ${prefix || '(none)'}`;
							pow3AltEl.className = 'bad';
						}

						// Winner by total work (not just length)
						const main2Valid = (!requireLink || linkedOk) && (!requirePow || (pow1Ok && pow2Ok));
						const fork2Valid = (!requireLink || block2Alt.prevHash === currentBlockHash) && (!requirePow || (pow1Ok && pow2AltOk));
						const main3Valid = main2Valid && (!requireLink || block3.prevHash === block2Hash) && (!requirePow || pow3Ok);
						const fork3Valid = fork2Valid && (!requireLink || block3Alt.prevHash === block2AltHash) && (!requirePow || pow3AltOk);

						const baseWork = leadingZeroWork(currentBlockHash);
						const mainWork = main2Valid
							? baseWork + leadingZeroWork(block2Hash) + (main3Valid ? leadingZeroWork(block3Hash) : 0)
							: 0;
						const forkWork = fork2Valid
							? baseWork + leadingZeroWork(block2AltHash) + (fork3Valid ? leadingZeroWork(block3AltHash) : 0)
							: 0;

						mainChainLenEl.textContent = String(mainWork);
						forkChainLenEl.textContent = String(forkWork);

						if (mainWork > forkWork) {
							winnerEl.textContent = 'main chain';
							winnerEl.className = 'ok';
						} else if (forkWork > mainWork) {
							winnerEl.textContent = 'fork chain';
							winnerEl.className = 'ok';
						} else if (mainWork === 0 && forkWork === 0) {
							winnerEl.textContent = 'none (both invalid)';
							winnerEl.className = 'bad';
						} else {
							winnerEl.textContent = 'tie (same work)';
							winnerEl.className = '';
						}
					} else {
						forkStatusEl.textContent = 'no fork';
						forkStatusEl.className = '';
						mainChainLenEl.textContent = '0';
						forkChainLenEl.textContent = '0';
						winnerEl.textContent = '(create fork)';
						winnerEl.className = '';
					}
				} catch (err) {
					hashEl.textContent = String(err);
					blockHashEl.textContent = String(err);
					validityEl.textContent = 'error';
					validityEl.className = 'bad';
					chainLinkEl.textContent = 'error';
					chainLinkEl.className = 'bad';
					block2HashEl.textContent = String(err);
					pow2El.textContent = 'error';
					pow2El.className = 'bad';
					chainStatusEl.textContent = 'error';
					chainStatusEl.className = 'bad';
					winnerEl.textContent = 'error';
					winnerEl.className = 'bad';
				}
			}

			async function currentBlock2Json() {
				const block2 = {
					index: 2,
					timestamp: block2Timestamp,
					data: block2DataEl.value,
					prevHash: lastBlock1Hash,
					nonce: Number(block2NonceEl.value) || 0,
				};
				return stableStringify(block2);
			}

			async function mine2() {
				if (mining2) return;
				mining2 = true;
				mine2Btn.disabled = true;
				stopMine2Btn.disabled = false;

				attempts2 = 0;
				const difficulty = Math.max(0, Math.min(8, Number(difficultyEl.value) || 0));
				const prefix = '0'.repeat(difficulty);

				try {
					let nonce = Math.max(0, Number(block2NonceEl.value) || 0);
					while (mining2) {
						block2NonceEl.value = String(nonce);
						const block2Json = await currentBlock2Json();
						const h2 = await sha256(block2Json);
						attempts2 += 1;

						if (h2.startsWith(prefix)) break;

						nonce += 1;

						if (attempts2 % 200 === 0) {
							await refresh();
							await new Promise((r) => setTimeout(r, 0));
						}
					}
				} finally {
					mining2 = false;
					mine2Btn.disabled = false;
					stopMine2Btn.disabled = true;
					await refresh();
				}
			}

			async function currentBlock2AltJson() {
				const block2Alt = {
					index: 2,
					timestamp: block2AltTimestamp,
					data: block2AltDataEl.value,
					prevHash: lastBlock1Hash,
					nonce: Number(block2AltNonceEl.value) || 0,
				};
				return stableStringify(block2Alt);
			}

			async function mine2Alt() {
				if (mining2Alt) return;
				mining2Alt = true;
				mine2AltBtn.disabled = true;
				stopMine2AltBtn.disabled = false;

				attempts2Alt = 0;
				const difficulty = Math.max(0, Math.min(8, Number(difficultyEl.value) || 0));
				const prefix = '0'.repeat(difficulty);

				try {
					let nonce = Math.max(0, Number(block2AltNonceEl.value) || 0);
					while (mining2Alt) {
						block2AltNonceEl.value = String(nonce);
						const block2AltJson = await currentBlock2AltJson();
						const h2Alt = await sha256(block2AltJson);
						attempts2Alt += 1;

						if (h2Alt.startsWith(prefix)) break;

						nonce += 1;

						if (attempts2Alt % 200 === 0) {
							await refresh();
							await new Promise((r) => setTimeout(r, 0));
						}
					}
				} finally {
					mining2Alt = false;
					mine2AltBtn.disabled = false;
					stopMine2AltBtn.disabled = true;
					await refresh();
				}
			}

			async function currentBlock3Json() {
				const block3 = {
					index: 3,
					timestamp: block3Timestamp,
					data: block3DataEl.value,
					prevHash: lastBlock2Hash,
					nonce: Number(block3NonceEl.value) || 0,
				};
				return stableStringify(block3);
			}

			async function mine3() {
				if (mining3) return;
				mining3 = true;
				mine3Btn.disabled = true;
				stopMine3Btn.disabled = false;

				attempts3 = 0;
				const difficulty = Math.max(0, Math.min(8, Number(difficultyEl.value) || 0));
				const prefix = '0'.repeat(difficulty);

				try {
					let nonce = Math.max(0, Number(block3NonceEl.value) || 0);
					while (mining3) {
						block3NonceEl.value = String(nonce);
						const block3Json = await currentBlock3Json();
						const h3 = await sha256(block3Json);
						attempts3 += 1;

						if (h3.startsWith(prefix)) break;

						nonce += 1;
						if (attempts3 % 200 === 0) {
							await refresh();
							await new Promise((r) => setTimeout(r, 0));
						}
					}
				} finally {
					mining3 = false;
					mine3Btn.disabled = false;
					stopMine3Btn.disabled = true;
					await refresh();
				}
			}

			async function currentBlock3AltJson() {
				const block3Alt = {
					index: 3,
					timestamp: block3AltTimestamp,
					data: block3AltDataEl.value,
					prevHash: lastBlock2AltHash,
					nonce: Number(block3AltNonceEl.value) || 0,
				};
				return stableStringify(block3Alt);
			}

			async function mine3Alt() {
				if (mining3Alt) return;
				mining3Alt = true;
				mine3AltBtn.disabled = true;
				stopMine3AltBtn.disabled = false;

				attempts3Alt = 0;
				const difficulty = Math.max(0, Math.min(8, Number(difficultyEl.value) || 0));
				const prefix = '0'.repeat(difficulty);

				try {
					let nonce = Math.max(0, Number(block3AltNonceEl.value) || 0);
					while (mining3Alt) {
						block3AltNonceEl.value = String(nonce);
						const block3AltJson = await currentBlock3AltJson();
						const h3Alt = await sha256(block3AltJson);
						attempts3Alt += 1;

						if (h3Alt.startsWith(prefix)) break;

						nonce += 1;
						if (attempts3Alt % 200 === 0) {
							await refresh();
							await new Promise((r) => setTimeout(r, 0));
						}
					}
				} finally {
					mining3Alt = false;
					mine3AltBtn.disabled = false;
					stopMine3AltBtn.disabled = true;
					await refresh();
				}
			}

			async function currentBlockJson() {
				const nonce = Number(nonceEl.value) || 0;
				const block = {
					index: 1,
					timestamp: blockTimestamp,
					data: blockDataEl.value,
					prevHash: prevHashEl.value.trim(),
					nonce,
				};
				return stableStringify(block);
			}

			async function mine() {
				if (mining) return;
				mining = true;
				mineBtn.disabled = true;
				stopMineBtn.disabled = false;

				attempts = 0;
				const difficulty = Math.max(0, Math.min(8, Number(difficultyEl.value) || 0));
				const prefix = '0'.repeat(difficulty);

				// Keep timestamp stable while mining.
				blockTimestamp = blockTimestamp || new Date().toISOString();

				try {
					let nonce = Math.max(0, Number(nonceEl.value) || 0);
					while (mining) {
						nonceEl.value = String(nonce);
						const blockJson = await currentBlockJson();
						const h = await sha256(blockJson);
						attempts += 1;

						if (h.startsWith(prefix)) {
							// Found a valid proof-of-work.
							storedBlockHash = h;
							break;
						}

						nonce += 1;

						// Yield to keep the UI responsive.
						if (attempts % 200 === 0) {
							await refresh();
							await new Promise((r) => setTimeout(r, 0));
						}
					}
				} finally {
					mining = false;
					mineBtn.disabled = false;
					stopMineBtn.disabled = true;
					await refresh();
				}
			}

			msgEl.addEventListener('input', refresh);
			blockDataEl.addEventListener('input', refresh);
			prevHashEl.addEventListener('input', refresh);
			nonceEl.addEventListener('input', refresh);
			difficultyEl.addEventListener('input', refresh);
			block2DataEl.addEventListener('input', refresh);
			block2NonceEl.addEventListener('input', refresh);
			newTimestampBtn.addEventListener('click', () => {
				blockTimestamp = new Date().toISOString();
				attempts = 0;
				storedBlockHash = '';
				refresh();
			});
			newBlock2TimestampBtn.addEventListener('click', () => {
				block2Timestamp = new Date().toISOString();
				refresh();
			});

			ruleLinkEl.addEventListener('change', refresh);
			rulePowEl.addEventListener('change', refresh);

			forkBtn.addEventListener('click', () => {
				if (!forkActive) {
					forkActive = true;
					block2AltTimestamp = new Date().toISOString();
					forkContainer.style.display = 'block';
					refresh();
				}
			});

			block2AltDataEl.addEventListener('input', refresh);
			block2AltNonceEl.addEventListener('input', refresh);
			block3DataEl.addEventListener('input', refresh);
			block3NonceEl.addEventListener('input', refresh);
			block3AltDataEl.addEventListener('input', refresh);
			block3AltNonceEl.addEventListener('input', refresh);

			newBlock2AltTimestampBtn.addEventListener('click', () => {
				block2AltTimestamp = new Date().toISOString();
				refresh();
			});
			newBlock3TimestampBtn.addEventListener('click', () => {
				block3Timestamp = new Date().toISOString();
				refresh();
			});
			newBlock3AltTimestampBtn.addEventListener('click', () => {
				block3AltTimestamp = new Date().toISOString();
				refresh();
			});

			mine2AltBtn.addEventListener('click', mine2Alt);
			stopMine2AltBtn.addEventListener('click', () => {
				mining2Alt = false;
			});
			mine3Btn.addEventListener('click', mine3);
			stopMine3Btn.addEventListener('click', () => {
				mining3 = false;
			});
			mine3AltBtn.addEventListener('click', mine3Alt);
			stopMine3AltBtn.addEventListener('click', () => {
				mining3Alt = false;
			});

			mine2Btn.addEventListener('click', mine2);
			stopMine2Btn.addEventListener('click', () => {
				mining2 = false;
			});
			storeHashBtn.addEventListener('click', async () => {
				try {
					const block = {
						index: 1,
						timestamp: blockTimestamp,
						data: blockDataEl.value,
						prevHash: prevHashEl.value.trim(),
						nonce: Number(nonceEl.value) || 0,
					};
					const blockJson = stableStringify(block);
					storedBlockHash = await sha256(blockJson);
					await refresh();
				} catch {
					// refresh() already shows errors
					await refresh();
				}
			});

			mineBtn.addEventListener('click', mine);
			stopMineBtn.addEventListener('click', () => {
				mining = false;
			});
			refresh();
		</script>
	</body>
</html>